# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14zeK5zZongd3OfShCTfti6FHcfI7z9y9
"""

!pip install git+https://github.com/tensorflow/examples.git

import tensorflow as tf
import matplotlib.pyplot as plt
import tensorflow_datasets as tfds
import numpy as np
import os
import time
from tensorflow.keras import layers 
from IPython.display import clear_output
from tensorflow_examples.models.pix2pix import pix2pix

datasets, metadata = tfds.load(
    'cycle_gan/apple2orange',
    with_info=True,
    as_supervised=True
)

train_x, train_y = datasets['trainA'], datasets['trainB']
test_x, test_y = datasets['testA'], datasets['testB']

BUFFER_SIZE = 1000
BATCH_SIZE = 1
org_imag_size = (286,286)
input_img_size = (256,256,3)

def resize_image(image):
  inmag = tf.image.resize(image, org_imag_size)
  image = tf.image.random_crop(image, size=input_img_size)
  image = tf.image.random_flip_left_right(image)
  return image 

def normalize_image(image):
  image = tf.cast(image, dtype=tf.float32)
  return (image / 127.5) - 1

def preprocess_train_img(image, labels):
  image = resize_image(image)
  image = normalize_image(image)
  return image 

def preprocess_test_img(image, lebels):
  image = normalize_image(image)
  return image

AUTOTUNE = tf.data.AUTOTUNE

train_x = train_x.cache().map(
    preprocess_train_img,
    num_parallel_calls=AUTOTUNE).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)
train_y = train_y.cache().map(
    preprocess_train_img,
    num_parallel_calls=AUTOTUNE).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)

test_x = test_x.cache().map(
    preprocess_test_img,
    num_parallel_calls=AUTOTUNE).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)
test_y = test_y.cache().map(
    preprocess_test_img,
    num_parallel_calls=AUTOTUNE).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)

OUTPUT_CHANNEL = 4

generator_g = pix2pix.unet_generator(OUTPUT_CHANNEL,"instancenorm")
generator_f = pix2pix.unet_generator(OUTPUT_CHANNEL,"instancenorm")

discriminator_x = pix2pix.discriminator("instancenorm",target=False)
discriminator_y = pix2pix.discriminator("instancenorm",target=False)

LAMBDA = 20

loss_obj = tf.keras.losses.BinaryCrossentropy(from_logits=True)

def generator_loss(generated):
  return loss_obj(tf.ones_like(generated),generated)

def discriminator_loss(real,generated):
  real_loss = loss_obj(tf.ones_like(real),real)
  generated_loss = loss_obj(tf.zeros(generated),generated)
  total_loss = real_loss + generated_loss
  return total_loss

def cycled_loss(ral_image, same_image):
  loss = tf.reduce_mean(tf.abs(real_image - same_image))
  return LAMBDA * loss

def identyti_loss(real_image, same_image):
  loss = tf.reduce_mean(tf.abs(real_image - same_image))
  return LAMBDA * 0.5 * loss

generator_g_optimizer = tf.keras.optimizers.Adam(2e-4,beta_1=0.5)
generator_f_optimizer = tf.keras.optimizers.Adam(2e-4,beta_1=0.5)

discriminator_x_optimizer = tf.keras.optimizers.Adam(2e-4,beta_1=0.5)
discriminator_y_optimizer = tf.keras.optimizers.Adam(2e-4,beta_1=0.5)

def train_model(real_x, real_y):
   with tf.GradientTape(persistent=True) as tape:
     
     fake_y = generator_g(real_x, training=True)
     cycle_x = generator_f(fake_y, training=True)

     fake_x = generator_f(real_y, training=True)
     cycle_y = generator_g(fake_x, training=True)

     same_x = generator_f(real_x, training=True)
     same_y = generator_g(real_y, training=True)

     disc_real_x = discriminator_x(real_x, training=True)
     disc_real_y = discriminator_y(real_y, training=True)

     disc_fake_x = discriminator_x(fake_x, training=True)
     disc_fake_y = discriminator_y(fake_y, training=True)

     gen_g_loss = generator_loss(disc_fake_x)
     gen_f_loss = generator_loss(disc_fake_y)

     cycle_total_loss = cycled_loss(real_x, cycle_x) + cycled_loss(real_y, cycle_y)

     total_gen_g_loss = gen_g_loss + cycle_total_loss + identyti_loss(real_y, same_y)
     total_gen_f_loss = gen_f_loss + cycle_total_loss + identyti_loss(real_x, same_x)

     disc_x_loss = discriminator_loss(disc_real_x, disc_fake_x)
     disc_y_loss = discriminator_loss(disc_real_y, disc_fake_y)